
## STEP : CREATE AI SERVICE MODULE

Create file: `/services/aiService.js`

```javascript
const { GoogleGenerativeAI } = require('@google/generative-ai');

class AIService {
  constructor() {
    this.genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY);
    this.model = this.genAI.getGenerativeModel({ model: "gemini-pro" });
  }

  async analyzeRolesForIdea(ideaData) {
    try {
      const { title, description, targetAudience, problemStatement, uniqueValue } = ideaData;
      
      // Construct the prompt for Gemini
      const prompt = `
        As an expert startup advisor, analyze the following startup idea and suggest 3-5 specific roles needed for the team.
        
        Startup Idea Details:
        - Title: ${title || 'Not provided'}
        - Description: ${description || 'Not provided'}
        - Target Audience: ${targetAudience || 'Not provided'}
        - Problem Statement: ${problemStatement || 'Not provided'}
        - Unique Value: ${uniqueValue || 'Not provided'}
        
        Based on this idea, suggest the most critical roles needed for success. Consider:
        - Technical requirements
        - Business needs
        - Marketing requirements
        - Design needs
        - Domain expertise
        
        Return ONLY a comma-separated list of role names (e.g., "Full Stack Developer, UI/UX Designer, Marketing Specialist").
        Keep role names concise and professional. Limit to 5 roles maximum.
        
        Roles:
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const suggestedRoles = response.text().trim();

      // Clean up the response
      const roles = suggestedRoles
        .split(',')
        .map(role => role.trim())
        .filter(role => role.length > 0)
        .slice(0, 5); // Limit to 5 roles

      return {
        success: true,
        roles: roles,
        rawResponse: suggestedRoles
      };

    } catch (error) {
      console.error('AI Role Analysis Error:', error);
      
      // Fallback to hardcoded logic if AI fails
      const fallbackRoles = this.getFallbackRoles(ideaData);
      
      return {
        success: false,
        roles: fallbackRoles,
        error: error.message,
        fallback: true
      };
    }
  }

  getFallbackRoles(ideaData) {
    // Fallback logic similar to frontend hardcoded approach
    const suggestedRoles = [];
    const content = `${ideaData.title || ''} ${ideaData.description || ''} ${ideaData.problemStatement || ''}`.toLowerCase();
    
    if (content.includes('app') || content.includes('software') || content.includes('platform') || content.includes('website') || content.includes('digital')) {
      suggestedRoles.push('Full Stack Developer');
    }
    if (content.includes('mobile') || content.includes('ios') || content.includes('android')) {
      suggestedRoles.push('Mobile Developer');
    }
    if (content.includes('ui') || content.includes('ux') || content.includes('design') || content.includes('interface')) {
      suggestedRoles.push('UI/UX Designer');
    }
    if (content.includes('data') || content.includes('analytics') || content.includes('ai') || content.includes('machine learning')) {
      suggestedRoles.push('Data Scientist');
    }
    if (content.includes('marketing') || content.includes('social media') || content.includes('promotion')) {
      suggestedRoles.push('Marketing Specialist');
    }
    if (content.includes('business') || content.includes('strategy') || content.includes('management')) {
      suggestedRoles.push('Business Analyst');
    }
    
    // Default roles if no matches
    if (suggestedRoles.length === 0) {
      return ['Project Manager', 'Developer', 'Designer'];
    }
    
    return [...new Set(suggestedRoles)].slice(0, 4);
  }
}

module.exports = new AIService();
```

## STEP 4: CREATE API ENDPOINT

Create/update file: `/routes/ai.js` or add to existing routes file:

```javascript
const express = require('express');
const router = express.Router();
const aiService = require('../services/aiService');
const authMiddleware = require('../middleware/auth'); // Your auth middleware

// POST /api/ai/analyze-roles
router.post('/analyze-roles', authMiddleware, async (req, res) => {
  try {
    const { title, description, targetAudience, problemStatement, uniqueValue } = req.body;
    
    // Validation
    if (!title && !description) {
      return res.status(400).json({
        success: false,
        message: 'Title or description is required for analysis'
      });
    }

    const ideaData = {
      title: title?.trim(),
      description: description?.trim(),
      targetAudience: targetAudience?.trim(),
      problemStatement: problemStatement?.trim(),
      uniqueValue: uniqueValue?.trim()
    };

    console.log('Analyzing roles for idea:', { title: ideaData.title });

    const result = await aiService.analyzeRolesForIdea(ideaData);

    res.json({
      success: true,
      data: {
        roles: result.roles,
        aiGenerated: result.success,
        fallback: result.fallback || false
      },
      message: result.success ? 'Roles analyzed successfully with AI' : 'Roles generated with fallback logic'
    });

  } catch (error) {
    console.error('Role analysis endpoint error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to analyze roles',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router;
```

## STEP 5: REGISTER ROUTES IN MAIN APP

In your main app file (app.js or server.js):

```javascript
// Add this with your other route imports
const aiRoutes = require('./routes/ai');

// Add this with your other route registrations
app.use('/api/ai', aiRoutes);
```

## STEP 6: UPDATE FRONTEND TO USE API

Replace the hardcoded `analyzeRolesWithAI` function in NewPostSection.js:

```javascript
// AI Role Analysis function
const analyzeRolesWithAI = async () => {
  setAiAnalyzing(true);
  
  try {
    const ideaContent = {
      title: form.title,
      description: form.description,
      targetAudience: form.targetAudience,
      problemStatement: form.problemStatement,
      uniqueValue: form.uniqueValue
    };
    
    console.log('Sending idea to AI for analysis...');
    
    const response = await fetch('/api/ai/analyze-roles', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify(ideaContent)
    });
    
    if (!response.ok) {
      throw new Error(`API request failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.success && data.data.roles) {
      // Set the AI-suggested roles to the input
      setNeededRoles(data.data.roles.join(', '));
      
      console.log('AI analysis result:', {
        roles: data.data.roles,
        aiGenerated: data.data.aiGenerated,
        fallback: data.data.fallback
      });
    } else {
      throw new Error(data.message || 'Failed to get role suggestions');
    }
    
  } catch (err) {
    console.error('AI analysis error:', err);
    // Fallback to default roles
    setNeededRoles('Developer, Designer, Marketing Specialist');
    setError('AI analysis failed, using default suggestions');
  } finally {
    setAiAnalyzing(false);
  }
};
```

## STEP 7: ERROR HANDLING AND LOGGING

Add logging middleware or enhance existing logging:

```javascript
// In your logging middleware or service
const logAIUsage = (userId, ideaTitle, success, roles) => {
  console.log(`AI Role Analysis - User: ${userId}, Idea: "${ideaTitle}", Success: ${success}, Roles: [${roles.join(', ')}]`);
  
  // Optional: Store in database for analytics
  // await AIUsageLog.create({ userId, ideaTitle, success, roles, timestamp: new Date() });
};
```

## STEP 8: RATE LIMITING (RECOMMENDED)

Add rate limiting for the AI endpoint:

```javascript
const rateLimit = require('express-rate-limit');

const aiRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 requests per windowMs
  message: {
    success: false,
    message: 'Too many AI analysis requests, please try again later'
  }
});

// Apply to AI routes
router.post('/analyze-roles', aiRateLimit, authMiddleware, async (req, res) => {
  // ... existing code
});
```

## STEP 9: TESTING THE IMPLEMENTATION

### Test the API endpoint directly:
```bash
curl -X POST http://localhost:2000/api/ai/analyze-roles \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "title": "AI-powered study app for students",
    "description": "An app that helps students plan and track their study routines",
    "targetAudience": "University students",
    "problemStatement": "Students struggle to manage study time effectively"
  }'
```

Expected response:
```json
{
  "success": true,
  "data": {
    "roles": ["Mobile Developer", "UI/UX Designer", "Data Scientist", "Product Manager"],
    "aiGenerated": true,
    "fallback": false
  },
  "message": "Roles analyzed successfully with AI"
}
```

## STEP 10: MONITORING AND OPTIMIZATION

### Add monitoring for:
- API response times
- AI service success/failure rates
- Token usage (if applicable)
- User satisfaction with suggestions

### Performance optimizations:
- Cache common role suggestions
- Implement request deduplication
- Add timeout handling for AI requests

## SECURITY CONSIDERATIONS

1. **API Key Security**: Never expose your Gemini API key in frontend code
2. **Rate Limiting**: Implement proper rate limiting to prevent abuse
3. **Input Validation**: Sanitize all user inputs before sending to AI
4. **Authentication**: Ensure only authenticated users can access AI features
5. **Logging**: Log AI usage but avoid logging sensitive data

## COST MANAGEMENT

1. **Monitor Usage**: Track your Google AI API usage regularly
2. **Implement Caching**: Cache responses for identical inputs
3. **Set Limits**: Implement daily/monthly usage limits per user
4. **Fallback Strategy**: Always have a non-AI fallback option

## DEPLOYMENT CHECKLIST

- [ ] Environment variables configured in production
- [ ] API key properly secured
- [ ] Rate limiting enabled
- [ ] Error handling tested
- [ ] Fallback logic working
- [ ] Frontend integration tested
- [ ] Monitoring/logging in place
- [ ] Usage limits configured

## TROUBLESHOOTING

### Common Issues:
1. **API Key Invalid**: Verify key is correctly set in environment
2. **CORS Issues**: Ensure proper CORS configuration for frontend requests
3. **Timeout Errors**: Implement proper timeout handling for AI requests
4. **Rate Limit Hit**: Implement exponential backoff retry logic

### Debug Steps:
1. Check server logs for detailed error messages
2. Test API endpoint independently with curl/Postman
3. Verify frontend network requests in browser dev tools
4. Monitor AI service response times and success rates

This implementation provides a robust, production-ready AI role analysis feature that integrates seamlessly with your existing Squad application frontend.